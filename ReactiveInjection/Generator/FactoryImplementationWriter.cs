using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;
using ReactiveInjection.Tokens;
// ReSharper disable ConvertIfStatementToReturnStatement

// ReSharper disable MemberCanBeMadeStatic.Global

namespace ReactiveInjection.Generator;

internal static class FactoryImplementationWriter
{
    public static string GenerateCSharp(FactoryDependencyTree tree)
    {
        //We are aiming for early C# here
        
        var w = new IndentedWriter();
        WriteFileHeader(w);
        
        w.WriteLine($"namespace {tree.FactoryType.Namespace}");
        w.WriteLine('{');
        w.Push();

        WriteClassAttributes(w);
        w.WriteLine($"partial class {tree.FactoryType.Name}");
        w.WriteLine('{');
        w.Push();

        var services = new Dictionary<string, string>(); //Map of service type to service field name
        
        //Create readonly fields for services
        for (var i= 0; i < tree.Services.Length; i++)
        {
            var type = tree.Services[i];
            services.Add(type.CSharpName, $"this._service{i}");
            w.WriteLine($"private readonly {type.CSharpName} _service{i};");
        }
        
        w.WriteLine();
        
        //Create readonly fields for shared state
        var sharedState = new Dictionary<string, string>();
        for (var i = 0; i < tree.SharedState.Length; i++)
        {
            var type = tree.SharedState[i];
            sharedState.Add(type.CSharpName, $"this._state{i}");
            w.WriteLine($"private readonly {type.CSharpName} _state{i} = new {type.CSharpName}();");
        }

        w.WriteLine();
        
        //Generate DI constructor
        w.Write($"public {tree.FactoryType.Name}(");
        WriteParameters(w, tree.Services, (t, i) => $"{t.CSharpName} service{i}");
        w.WriteRawLine(')');
        w.WriteLine('{');
        w.Push();
        for (var i = 0; i < tree.Services.Length; i++)
            w.WriteLine($"this._service{i} = service{i};");
        w.Pop();
        w.WriteLine('}');
        
        //Write view model methods
        //Short name is method name
        foreach (var vm in tree.ViewModels)
        {
            w.WriteLine();
            
            w.Write($"public {vm.Type.CSharpName} {vm.Type.Name}(");
            
            WriteParameters(w, 
                vm.MethodParams,
                p => $"{p.Type.CSharpName} {p.Name}");
            
            w.WriteRawLine(')');
            w.WriteLine('{');
            
            w.Push();
            
            w.Write($"return new {vm.Type.CSharpName}(");
            
            WriteParameters(w, 
                vm.Constructor.Parameters, 
                param =>
                {
                    //If is wrapping factory type, then use 'this'
                    if (param.Type.Equals(tree.FactoryType))
                        return "this";
                    
                    if (Attributes.HasFromServicesAttribute(param))
                        return services[param.Type.CSharpName];

                    if (Attributes.HasSharedStateAttribute(param))
                        return sharedState[param.Type.CSharpName];
                    
                    //Comes from method parameter
                    return param.Name;
                });
            
            w.WriteRawLine(");");
            w.Pop();
            w.WriteLine('}');
        }
        
        //sb.Pop();
        w.PopThenWriteLine("}"); //End of type declaration
        w.PopThenWriteLine("}"); //End of namespace declaration
        
        return w.ToString();
    }

    private static void WriteParameters<T>(IndentedWriter writer,
        IEnumerable<T> parameters,
        Func<T, string> toString)
    {
        writer.WriteRaw(string.Join(", ", parameters.Select(toString)));
    }
    
    private static void WriteParameters<T>(IndentedWriter writer,
        IEnumerable<T> parameters,
        Func<T, int, string> toString)
    {
        writer.WriteRaw(string.Join(", ", parameters.Select(toString)));
    }

    private static void WriteFileHeader(IndentedWriter writer)
    {
        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine("// This file was automatically generated by the ReactiveInjection source generator.");
        writer.WriteLine("// Do not edit this file manually since it will be automatically overwritten.");
        writer.WriteLine("#nullable disable");
    }
    
    private static void WriteClassAttributes(IndentedWriter writer)
    {
        writer.WriteLine($"[global::{typeof(BrowsableAttribute).FullName}(false)]");
        
        writer.WriteLine($"[global::{typeof(DebuggerStepThroughAttribute).FullName}()]");
        writer.WriteLine($"[global::{typeof(DebuggerNonUserCodeAttribute).FullName}()]");
        
        writer.WriteLine($"[global::{typeof(GeneratedCodeAttribute).FullName}(\"ReactiveInjection\", \"{Version}\")]");
    }

    private static Version Version => typeof(FactoryImplementationWriter).Assembly.GetName().Version;
}